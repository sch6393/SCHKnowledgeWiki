Oracle Text에 대한 자세한 설명
===

### DATASTORE
Text Index를 작성 시 가장 먼저 정의되는 문서 소스를 정의함. 기본 설정은 인덱싱을 위해 스트리밍해야 하는 텍스트 문서의 소스이며 데이터베이스의 테이블, 서버 파일 시스템, 웹 등 다양한 곳에서 가져온 소스 문서를 인덱싱할 수 있음.

|종류|설명|
|-|-|
|`DIRECT_DATASTORE`|데이터가 데이터베이스 테이블의 텍스트 열에 내부적으로 저장됨. 각 행은 하나의 문서로 인덱싱함. 기본 값|
|`MULTI_COLUMN_DATASTORE`|데이터가 데이터베이스 테이블의 둘 이상의 텍스트 열에 저장됨. 열을 연결해 가상 문서를 만들고 연결된 각 행을 단일 문서로 인덱싱함|
|`DETITAL_DATASTORE`|데이터가 텍스트 열에 내부적으로 저장됨. 문서는 세부 테이블의 텍스트 열에 저장됨|
|`NESTED_DATASTORE`|데이터가 중첩된 테이블에 저장되어 있음|
|`FILE_DATASTORE`|운영 체제 파일에 데이터가 저장되어 있음 (`CONTY` 인덱스만 지원)|
|`URL_DATASTORE`|웹을 통해 데이터가 저장되어 있음 (`CONTY` 인덱스만 지원)|
|`USER_DATASTORE`|사용자가 정의한 저장 프로시저에 의해 문서가 인덱스 시간에 합성되어 있음|

<br>

### FILTER
문서가 데이터 저장소에서 스트리밍되면 인덱싱되기 전에 필터를 통과하는데 이 단계에서 텍스트 스트림은 Oracle Text 처리 엔진에 의해 인식할 수 있는 형식으로 변환될 수 있음. 문서를 인덱싱하려면 MS Word, PDF와 같은 유형의 문서를 텍스트로 포맷해야함

|종류|설명|
|-|-|
|`NULL_FILTER`|텍스트 스트림에 적용할 필터링이 없음. 기본 값 (`TXT`, `HTML`, `XML` 형식의 문서는 필터링이 필요하지 않음)|
|`AUTO_FILTER`|문서의 형식을 자동으로 감지해 해당 문서를 마크업 텍스트로 필터링 (변환) 하고 데이터베이스 문자 집합과 일치하도록 문서 문자 집합을 변환|
|`USER_FILTER` 또는 `PROCEDURE_FILTER`|텍스트 스트림을 필터링하기 위해 자체 사용자 정의 필터를 생성하여 적용함. 사용자 정의 필터는 파일 시스템에서 실행되는 외부 또는 내부에서 PL/SQL 프로시저 형태로 만들 수 있음.<br>오라클에서 텍스트 인덱스에 외부 사용자 정의 필터를 사용할 수 있도록 하려면 `USER_FILTER` 를 사용해야 하고 내부 PL/SQL 필터의 경우 `PROCEDURE_FILTER` 를 사용해야 함|
|`CHARSET_FILTER`|Oracle Text 엔진은 문서 스트림의 문자 집합이 데이터베이스 문자 집합에 포함되어 있을 거라는 전제에 동작함. 만약 데이터베이스 문자 집합에 포함되어 있지 않다면 `CHARSET_FILTER` 를 사용하여 문서 스트림의 문자 집합을 데이터베이스 문자 집합으로 변환할 수 있음|

<br>

### SECTIONER
텍스트 스트림이 필터를 통과하고 필요한 변환이 적용됐다면 SECTIONER 단계로 진행함. SECTIONER 작업은 텍스트 스트림을 내부 문서 구조 (`HTML`, `XML`) 를 기반으로 여러 SECTION으로 나눔으로서 특정 SECTION (WIND 연산자를 이용) 으로 검색을 제한하여 효율적인 텍스트 검색이 될 수 있도록 함

|종류|설명|
|-|-|
|`NULL_SECTION_GROUP`|텍스트 스트림을 여러 SECTION으로 나누지 않음. 기본 값|
|`BASIC_SECTION_GROUP`|텍스트 스트림에서 시작 태그와 끝 태그가 `<A>` 또는 `</A>` 형태인 SECTION을 정의함|
|`HTML_SECTION_GROUP`|`HTML` 문서 스트림을 SECTION으로 나눌 때 사용|
|`XML_SECTION_GROUP`|`XML` 문서 스트림을 SECTION으로 나눌 때 사용|
|`AUTO_SECTION_GROUP`|`XML` 문서에서 시작/종료 태그 쌍별로 영역 SECTION을 자동으로 생성|
|`PATH_SECTION_GROUP`|`XML` 문서를 인덱싱함. 기본적으로 `AUTO_SECTION_GROUP` 처럼 동작하지만 추가로 `INPATH`, `HASPATH` 연산자로 경로 검색이 가능함|
|`NEWS_SECTION_GROUP`|RFC 1036 표준에 따른 뉴스 그룹 형식의 문서에서 SECTION을 정의할 때 사용|

<br>

### LEXER
SECTION 단계가 끝나면 LEXER 단계로 진행함. LEXER는 기본적으로 문서 스트림과 관련된 언어를 정의함

|종류|설명|
|-|-|
|`BASIC_LEXER`|영어, 프랑스어, 독일어, 스페인어와 같은 공백으로 제한된 언어를 색인할 수 있음. 이러한 언어 중 일부의 경우 대체 철자법, 복합 단어 색인 및 기본 문자 변환을 사용할 수 있음. 기본 값|
|`AUTO_LEXER`|문서와 관련된 언어를 자동으로 결정함. 테이블 열에 다른 언어의 문서가 포함되어 있는 경우에는 `AUTO_LEXER` 를 사용해야 함|
|`MULTI_LEXER`|영어, 독일어, 일본어 등 다양한 언어의 문서가 포함된 색인표에 사용함|
|`USER_LEXER`|특정 언어를 인덱싱하기 위한 자체 LEXER를 생성|
|`WORLD_LEXER`|서로 다른 언어의 문서를 포함하는 색인표를 만들고 문서의 언어를 자동으로 탐지함|

<br>

### WORDLIST & STOPLIST
LEXER 단계가 끝나면 문서 (레코드) 는 Oracle Text 엔진에 의해 인덱싱될 준비가 완료됨. 그러나 문서를 인덱싱하기 전에 텍스트 엔진은 `STOPLIST` 를 사용해 인덱싱 되지 않는 단어 (토큰) 을 정의함. 또한 `WORDLIST` 를 사용해 스머닝 (언어적 뿌리가 동일한 단어), 퍼지 매칭 (유사한 철자의 단어) 및 와일드카드 쿼리를 처리하는 방법을 정의함. 자체적인 `STOPLIST`, `WORDLIST` 를 생성할 수는 있으나 기본적으로는 각각 `BASIC_STOPLIST`, `BASIC_WORDLIST` 옵션을 사용

<br>

### STORAGE
Oracle Text 인덱스를 데이터베이스에 저장할 방법을 정의함. 기본 값은 Oracle Text 인덱스를 구성하는 내부 데이터베이스 테이블과 인덱스의 테이블 공간 및 생성 매개 변수를 정의함. Oracle Text 인덱스는 내부적으로 테이블과 인덱스 집합으로 구성되므로 내부 테이블과 인덱스에 대해 서로 다른 스토리지로 설정할 수도 있음

<br>

### TEXT INDEX TYPE
Oracle Text는 텍스트 검색에 필요한 세 가지 유형의 인덱스가 있음

|종류|설명|
|-|-|
|표준 (`CONTEXT`)|큰 텍스트 문서 (MS Word, PDF 등) 나 웹 페이지 (HTML) 를 통한 전통적인 전체 텍스트 검색에 사용|
|카탈로그 (`CTXCAT`)|eBusiness 카탈로그를 위해 설계된 텍스트 인덱스. 웹 속도로 유연한 검색 및 정렬을 제공합니다. 다른 관계형 데이터와 함께 인덱싱해야 하는 텍스트의 작은 조각을 인덱싱하는 데 초점이 맞춰져 있음|
|분류 (`CTXRULE`)|문서 분류, 라우팅 응용 프로그램을 구축하는 데 사용. 쿼리 테이블에 생성되며 쿼리는 분류, 라우팅 기준을 정의함|

<br>

### Oracle Text 인덱스 개체
모든 설정이 정의되고 Oracle Text 엔진에 의해 문서가 인덱싱되면 텍스트 엔진은 데이터베이스 개체 집합을 생성함. 일반적으로 `$I`, `$K`, `$N`, `$R` 테이블로 구성되어 있으며 해당 테이블에는 `DR$`, 텍스트 인덱스, 접미사와 연결된 이름을 가짐

|종류|설명|
|-|-|
|`$I` (Index Data Table)|인덱싱 중인 실제 데이터가 포함되어 있으며 텍스트 문서에서 생성된 모든 단어 (토큰) 가 해당 테이블에 저장되어 있음. 해당 테이블의 토큰은 `DR${index_name}$X` 형식의 이름을 가진 B Tree 인덱스를 사용하여 인덱싱됨|
|`$K` (Keymap Table)|해당 테이블은 각 행 (텍스트 문서 포함) 이 단일 `DOCID / ROWID` 쌍으로 구성되어 있음. 내부 `DOCID` 값을 외부 `ROWID` 값에 매핑하고 효율적인 검색을 하기 위한 Index Organized 테이블|
|`$R` (ROWID Table)|`$K` 테이블의 반대 검색 테이블. 즉, `DOCID` 값을 알 때 `ROWID` 를 가져오기 위해 설계된 테이블. 해당 테이블의 항목은 `DRC${index_name}$R` 형식의 이름을 가진 B Tree 인덱스를 사용하여 인덱싱됨|
|`$N` (Negative List Table)|삭제된 `DOCID` 값 목록이 포함되어 있으며 해당 `DOCID` 값은 인덱스 최적화 프로세스에 의해 정리됨. 해당 테이블은 효율적인 정리 작업을 위해 인덱스로 구성된 테이블로 작성됨|
|`$P`|P_TABLE_CLAUSE|
|`$S`|S_TABLE_CLAUSE|
|`$G`|텍스트 인덱스의 유지 보수 및 성능을 개선하는데에 사용되며 `$I` 테이블의 매개 역할을 함. 메모리 (버퍼 캐시) 에 보관될 수 있음|

<br>

### 텍스트 쿼리 처리 방법
1. 인덱싱된 룩업 (Indexed Lookup)

    일반적인 경우 커널은 텍스트 인덱스에 특정 텍스트 검색을 만족시키는 모든 ROWID (배치형으로 반환) 를 요청함. 여기서 오라클은 토큰 테이블 (`$I`) 을 조사하는데 문서에서 토큰이 나타나는 ROW 및 WORD 위치에 대한 정보뿐만 아니라 인덱싱된 모든 토큰이 포함됨. 그러나 `$I` 테이블의 행 정보는 내부 `DOCID` 값으로 저장되어 있고 이는 외부 `ROWID` 값으로 변환되어야 하기에 변환 작업은 `$R` 테이블로 룩업을 수행함으로써 변환됨

1. 함수 조회
    커널이 개별 `ROWID` 를 텍스트 인덱스에 전달하고 그 특정 `ROWID` 가 특정 텍스트 기준을 통과하는지를 확인함. 오라클은 토큰 테이블 (`$I`) 을 조사하는데 해당 테이블은 토큰은 문서에서 나타나는 ROW 및 WORD 위치에 대한 정보는 가지고 있지만 행 정보는 알 수 없음. 행 정보는 내부 `DOCID` 값에 저장되므로 텍스트 인덱스에 전달되는 개별 `ROWID` 에 대한 `DOCID` 를 먼저 찾아야 함. 따라서 `$K` 테이블에서 `ROWID` 와 `DOCID` 사이의 매핑 정보를 찾아 매칭하게 되고 적은 수의 `ROWID` 만 텍스트 인덱스에 대해 확인하게 됨

<br>
